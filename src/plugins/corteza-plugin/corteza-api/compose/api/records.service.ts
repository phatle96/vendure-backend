/**
 * Corteza compose API
 * Corteza compose REST API definition
 *
 * The version of the OpenAPI document: 2022.9
 * Contact: info@cortezaproject.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { AxiosResponse } from 'axios';
import { Observable, from, of, switchMap } from 'rxjs';
import { ComposeNamespaceImportPostRequest } from '../model/composeNamespaceImportPostRequest';
import { ComposeNamespaceNamespaceIDModuleModuleIDRecordAttachmentPostRequest } from '../model/composeNamespaceNamespaceIDModuleModuleIDRecordAttachmentPostRequest';
import { ComposeNamespaceNamespaceIDModuleModuleIDRecordDeleteRequest } from '../model/composeNamespaceNamespaceIDModuleModuleIDRecordDeleteRequest';
import { ComposeNamespaceNamespaceIDModuleModuleIDRecordExecProcedurePostRequest } from '../model/composeNamespaceNamespaceIDModuleModuleIDRecordExecProcedurePostRequest';
import { ComposeNamespaceNamespaceIDModuleModuleIDRecordImportSessionIDPatchRequest } from '../model/composeNamespaceNamespaceIDModuleModuleIDRecordImportSessionIDPatchRequest';
import { ComposeNamespaceNamespaceIDModuleModuleIDRecordPostRequest } from '../model/composeNamespaceNamespaceIDModuleModuleIDRecordPostRequest';
import { ComposeNamespaceNamespaceIDModuleModuleIDRecordRecordIDPostRequest } from '../model/composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDPostRequest';
import { ComposeNamespaceNamespaceIDModuleModuleIDRecordRecordIDTriggerPostRequest } from '../model/composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDTriggerPostRequest';
import { ComposeNamespaceNamespaceIDTriggerPostRequest } from '../model/composeNamespaceNamespaceIDTriggerPostRequest';
import { Configuration } from '../configuration';
import { COLLECTION_FORMATS } from '../variables';


@Injectable()
export class RecordsService {

    protected basePath = 'http://192.46.224.41:18080/api';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();
    protected httpClient: HttpService;

    constructor(httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
        this.httpClient = configuration?.httpClient || httpClient;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * Uploads attachment and validates it against record field requirements
     * 
     * @param namespaceID Namespace ID
     * @param moduleID Module ID
     * @param composeNamespaceNamespaceIDModuleModuleIDRecordAttachmentPostRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public composeNamespaceNamespaceIDModuleModuleIDRecordAttachmentPost(namespaceID: string, moduleID: string, composeNamespaceNamespaceIDModuleModuleIDRecordAttachmentPostRequest?: ComposeNamespaceNamespaceIDModuleModuleIDRecordAttachmentPostRequest, ): Observable<AxiosResponse<any>>;
    public composeNamespaceNamespaceIDModuleModuleIDRecordAttachmentPost(namespaceID: string, moduleID: string, composeNamespaceNamespaceIDModuleModuleIDRecordAttachmentPostRequest?: ComposeNamespaceNamespaceIDModuleModuleIDRecordAttachmentPostRequest, ): Observable<any> {
        if (namespaceID === null || namespaceID === undefined) {
            throw new Error('Required parameter namespaceID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordAttachmentPost.');
        }

        if (moduleID === null || moduleID === undefined) {
            throw new Error('Required parameter moduleID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordAttachmentPost.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/x-www-form-urlencoded'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/compose/namespace/${encodeURIComponent(String(namespaceID))}/module/${encodeURIComponent(String(moduleID))}/record/attachment`,
                    composeNamespaceNamespaceIDModuleModuleIDRecordAttachmentPostRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Delete record row from module section
     * 
     * @param namespaceID Namespace ID
     * @param moduleID Module ID
     * @param composeNamespaceNamespaceIDModuleModuleIDRecordDeleteRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public composeNamespaceNamespaceIDModuleModuleIDRecordDelete(namespaceID: string, moduleID: string, composeNamespaceNamespaceIDModuleModuleIDRecordDeleteRequest?: ComposeNamespaceNamespaceIDModuleModuleIDRecordDeleteRequest, ): Observable<AxiosResponse<any>>;
    public composeNamespaceNamespaceIDModuleModuleIDRecordDelete(namespaceID: string, moduleID: string, composeNamespaceNamespaceIDModuleModuleIDRecordDeleteRequest?: ComposeNamespaceNamespaceIDModuleModuleIDRecordDeleteRequest, ): Observable<any> {
        if (namespaceID === null || namespaceID === undefined) {
            throw new Error('Required parameter namespaceID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordDelete.');
        }

        if (moduleID === null || moduleID === undefined) {
            throw new Error('Required parameter moduleID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordDelete.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/x-www-form-urlencoded'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<any>(`${this.basePath}/compose/namespace/${encodeURIComponent(String(namespaceID))}/module/${encodeURIComponent(String(moduleID))}/record/`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Executes server-side procedure over one or more module records
     * 
     * @param namespaceID Namespace ID
     * @param moduleID Module ID
     * @param procedure Name of procedure to execute
     * @param composeNamespaceNamespaceIDModuleModuleIDRecordExecProcedurePostRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public composeNamespaceNamespaceIDModuleModuleIDRecordExecProcedurePost(namespaceID: string, moduleID: string, procedure: string, composeNamespaceNamespaceIDModuleModuleIDRecordExecProcedurePostRequest?: ComposeNamespaceNamespaceIDModuleModuleIDRecordExecProcedurePostRequest, ): Observable<AxiosResponse<any>>;
    public composeNamespaceNamespaceIDModuleModuleIDRecordExecProcedurePost(namespaceID: string, moduleID: string, procedure: string, composeNamespaceNamespaceIDModuleModuleIDRecordExecProcedurePostRequest?: ComposeNamespaceNamespaceIDModuleModuleIDRecordExecProcedurePostRequest, ): Observable<any> {
        if (namespaceID === null || namespaceID === undefined) {
            throw new Error('Required parameter namespaceID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordExecProcedurePost.');
        }

        if (moduleID === null || moduleID === undefined) {
            throw new Error('Required parameter moduleID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordExecProcedurePost.');
        }

        if (procedure === null || procedure === undefined) {
            throw new Error('Required parameter procedure was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordExecProcedurePost.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/x-www-form-urlencoded'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/compose/namespace/${encodeURIComponent(String(namespaceID))}/module/${encodeURIComponent(String(moduleID))}/record/exec/${encodeURIComponent(String(procedure))}`,
                    composeNamespaceNamespaceIDModuleModuleIDRecordExecProcedurePostRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Exports records that match 
     * 
     * @param namespaceID Namespace ID
     * @param moduleID Module ID
     * @param filename Filename to use
     * @param ext Export format
     * @param fields Fields to export
     * @param filter Filtering condition
     * @param timezone Convert times to this timezone
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public composeNamespaceNamespaceIDModuleModuleIDRecordExportfilenameExtGet(namespaceID: string, moduleID: string, filename: string, ext: string, fields: Array<string>, filter?: string, timezone?: string, ): Observable<AxiosResponse<any>>;
    public composeNamespaceNamespaceIDModuleModuleIDRecordExportfilenameExtGet(namespaceID: string, moduleID: string, filename: string, ext: string, fields: Array<string>, filter?: string, timezone?: string, ): Observable<any> {
        if (namespaceID === null || namespaceID === undefined) {
            throw new Error('Required parameter namespaceID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordExportfilenameExtGet.');
        }

        if (moduleID === null || moduleID === undefined) {
            throw new Error('Required parameter moduleID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordExportfilenameExtGet.');
        }

        if (filename === null || filename === undefined) {
            throw new Error('Required parameter filename was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordExportfilenameExtGet.');
        }

        if (ext === null || ext === undefined) {
            throw new Error('Required parameter ext was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordExportfilenameExtGet.');
        }

        if (fields === null || fields === undefined) {
            throw new Error('Required parameter fields was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordExportfilenameExtGet.');
        }

        let queryParameters = new URLSearchParams();
        if (filter !== undefined && filter !== null) {
            queryParameters.append('filter', <any>filter);
        }
        if (fields) {
            fields.forEach((element) => {
                queryParameters.append('fields', <any>element);
            })
        }
        if (timezone !== undefined && timezone !== null) {
            queryParameters.append('timezone', <any>timezone);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<any>(`${this.basePath}/compose/namespace/${encodeURIComponent(String(namespaceID))}/module/${encodeURIComponent(String(moduleID))}/record/export${encodeURIComponent(String(filename))}.${encodeURIComponent(String(ext))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * List/read records from module section
     * 
     * @param namespaceID Namespace ID
     * @param moduleID Module ID
     * @param query Record filtering query
     * @param meta Record meta data
     * @param deleted Exclude (0, default), include (1) or return only (2) deleted records
     * @param limit Limit
     * @param incTotal Include total records counter
     * @param incPageNavigation Include page navigation
     * @param pageCursor Page cursor
     * @param sort Sort items
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public composeNamespaceNamespaceIDModuleModuleIDRecordGet(namespaceID: string, moduleID: string, query?: string, meta?: string, deleted?: string, limit?: string, incTotal?: boolean, incPageNavigation?: boolean, pageCursor?: string, sort?: string, ): Observable<AxiosResponse<any>>;
    public composeNamespaceNamespaceIDModuleModuleIDRecordGet(namespaceID: string, moduleID: string, query?: string, meta?: string, deleted?: string, limit?: string, incTotal?: boolean, incPageNavigation?: boolean, pageCursor?: string, sort?: string, ): Observable<any> {
        if (namespaceID === null || namespaceID === undefined) {
            throw new Error('Required parameter namespaceID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordGet.');
        }

        if (moduleID === null || moduleID === undefined) {
            throw new Error('Required parameter moduleID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordGet.');
        }

        let queryParameters = new URLSearchParams();
        if (query !== undefined && query !== null) {
            queryParameters.append('query', <any>query);
        }
        if (meta !== undefined && meta !== null) {
            queryParameters.append('meta', <any>meta);
        }
        if (deleted !== undefined && deleted !== null) {
            queryParameters.append('deleted', <any>deleted);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (incTotal !== undefined && incTotal !== null) {
            queryParameters.append('incTotal', <any>incTotal);
        }
        if (incPageNavigation !== undefined && incPageNavigation !== null) {
            queryParameters.append('incPageNavigation', <any>incPageNavigation);
        }
        if (pageCursor !== undefined && pageCursor !== null) {
            queryParameters.append('pageCursor', <any>pageCursor);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters.append('sort', <any>sort);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<any>(`${this.basePath}/compose/namespace/${encodeURIComponent(String(namespaceID))}/module/${encodeURIComponent(String(moduleID))}/record/`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Initiate record import session
     * 
     * @param namespaceID Namespace ID
     * @param moduleID Module ID
     * @param composeNamespaceImportPostRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public composeNamespaceNamespaceIDModuleModuleIDRecordImportPost(namespaceID: string, moduleID: string, composeNamespaceImportPostRequest?: ComposeNamespaceImportPostRequest, ): Observable<AxiosResponse<any>>;
    public composeNamespaceNamespaceIDModuleModuleIDRecordImportPost(namespaceID: string, moduleID: string, composeNamespaceImportPostRequest?: ComposeNamespaceImportPostRequest, ): Observable<any> {
        if (namespaceID === null || namespaceID === undefined) {
            throw new Error('Required parameter namespaceID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordImportPost.');
        }

        if (moduleID === null || moduleID === undefined) {
            throw new Error('Required parameter moduleID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordImportPost.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/x-www-form-urlencoded'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/compose/namespace/${encodeURIComponent(String(namespaceID))}/module/${encodeURIComponent(String(moduleID))}/record/import`,
                    composeNamespaceImportPostRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Get import progress
     * 
     * @param namespaceID Namespace ID
     * @param moduleID Module ID
     * @param sessionID Import session
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public composeNamespaceNamespaceIDModuleModuleIDRecordImportSessionIDGet(namespaceID: string, moduleID: string, sessionID: string, ): Observable<AxiosResponse<any>>;
    public composeNamespaceNamespaceIDModuleModuleIDRecordImportSessionIDGet(namespaceID: string, moduleID: string, sessionID: string, ): Observable<any> {
        if (namespaceID === null || namespaceID === undefined) {
            throw new Error('Required parameter namespaceID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordImportSessionIDGet.');
        }

        if (moduleID === null || moduleID === undefined) {
            throw new Error('Required parameter moduleID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordImportSessionIDGet.');
        }

        if (sessionID === null || sessionID === undefined) {
            throw new Error('Required parameter sessionID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordImportSessionIDGet.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<any>(`${this.basePath}/compose/namespace/${encodeURIComponent(String(namespaceID))}/module/${encodeURIComponent(String(moduleID))}/record/import/${encodeURIComponent(String(sessionID))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Run record import
     * 
     * @param namespaceID Namespace ID
     * @param moduleID Module ID
     * @param sessionID Import session
     * @param composeNamespaceNamespaceIDModuleModuleIDRecordImportSessionIDPatchRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public composeNamespaceNamespaceIDModuleModuleIDRecordImportSessionIDPatch(namespaceID: string, moduleID: string, sessionID: string, composeNamespaceNamespaceIDModuleModuleIDRecordImportSessionIDPatchRequest?: ComposeNamespaceNamespaceIDModuleModuleIDRecordImportSessionIDPatchRequest, ): Observable<AxiosResponse<any>>;
    public composeNamespaceNamespaceIDModuleModuleIDRecordImportSessionIDPatch(namespaceID: string, moduleID: string, sessionID: string, composeNamespaceNamespaceIDModuleModuleIDRecordImportSessionIDPatchRequest?: ComposeNamespaceNamespaceIDModuleModuleIDRecordImportSessionIDPatchRequest, ): Observable<any> {
        if (namespaceID === null || namespaceID === undefined) {
            throw new Error('Required parameter namespaceID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordImportSessionIDPatch.');
        }

        if (moduleID === null || moduleID === undefined) {
            throw new Error('Required parameter moduleID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordImportSessionIDPatch.');
        }

        if (sessionID === null || sessionID === undefined) {
            throw new Error('Required parameter sessionID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordImportSessionIDPatch.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/x-www-form-urlencoded'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<any>(`${this.basePath}/compose/namespace/${encodeURIComponent(String(namespaceID))}/module/${encodeURIComponent(String(moduleID))}/record/import/${encodeURIComponent(String(sessionID))}`,
                    composeNamespaceNamespaceIDModuleModuleIDRecordImportSessionIDPatchRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Create record in module section
     * 
     * @param namespaceID Namespace ID
     * @param moduleID Module ID
     * @param composeNamespaceNamespaceIDModuleModuleIDRecordPostRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public composeNamespaceNamespaceIDModuleModuleIDRecordPost(namespaceID: string, moduleID: string, composeNamespaceNamespaceIDModuleModuleIDRecordPostRequest?: ComposeNamespaceNamespaceIDModuleModuleIDRecordPostRequest, ): Observable<AxiosResponse<any>>;
    public composeNamespaceNamespaceIDModuleModuleIDRecordPost(namespaceID: string, moduleID: string, composeNamespaceNamespaceIDModuleModuleIDRecordPostRequest?: ComposeNamespaceNamespaceIDModuleModuleIDRecordPostRequest, ): Observable<any> {
        if (namespaceID === null || namespaceID === undefined) {
            throw new Error('Required parameter namespaceID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordPost.');
        }

        if (moduleID === null || moduleID === undefined) {
            throw new Error('Required parameter moduleID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordPost.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/x-www-form-urlencoded'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/compose/namespace/${encodeURIComponent(String(namespaceID))}/module/${encodeURIComponent(String(moduleID))}/record/`,
                    composeNamespaceNamespaceIDModuleModuleIDRecordPostRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Delete record row from module section
     * 
     * @param namespaceID Namespace ID
     * @param moduleID Module ID
     * @param recordID Record ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDDelete(namespaceID: string, moduleID: string, recordID: string, ): Observable<AxiosResponse<any>>;
    public composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDDelete(namespaceID: string, moduleID: string, recordID: string, ): Observable<any> {
        if (namespaceID === null || namespaceID === undefined) {
            throw new Error('Required parameter namespaceID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDDelete.');
        }

        if (moduleID === null || moduleID === undefined) {
            throw new Error('Required parameter moduleID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDDelete.');
        }

        if (recordID === null || recordID === undefined) {
            throw new Error('Required parameter recordID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDDelete.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<any>(`${this.basePath}/compose/namespace/${encodeURIComponent(String(namespaceID))}/module/${encodeURIComponent(String(moduleID))}/record/${encodeURIComponent(String(recordID))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Read records by ID from module section
     * 
     * @param namespaceID Namespace ID
     * @param moduleID Module ID
     * @param recordID Record ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDGet(namespaceID: string, moduleID: string, recordID: string, ): Observable<AxiosResponse<any>>;
    public composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDGet(namespaceID: string, moduleID: string, recordID: string, ): Observable<any> {
        if (namespaceID === null || namespaceID === undefined) {
            throw new Error('Required parameter namespaceID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDGet.');
        }

        if (moduleID === null || moduleID === undefined) {
            throw new Error('Required parameter moduleID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDGet.');
        }

        if (recordID === null || recordID === undefined) {
            throw new Error('Required parameter recordID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDGet.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<any>(`${this.basePath}/compose/namespace/${encodeURIComponent(String(namespaceID))}/module/${encodeURIComponent(String(moduleID))}/record/${encodeURIComponent(String(recordID))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Update records in module section
     * 
     * @param namespaceID Namespace ID
     * @param moduleID Module ID
     * @param recordID Record ID
     * @param composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDPostRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDPost(namespaceID: string, moduleID: string, recordID: string, composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDPostRequest?: ComposeNamespaceNamespaceIDModuleModuleIDRecordRecordIDPostRequest, ): Observable<AxiosResponse<any>>;
    public composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDPost(namespaceID: string, moduleID: string, recordID: string, composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDPostRequest?: ComposeNamespaceNamespaceIDModuleModuleIDRecordRecordIDPostRequest, ): Observable<any> {
        if (namespaceID === null || namespaceID === undefined) {
            throw new Error('Required parameter namespaceID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDPost.');
        }

        if (moduleID === null || moduleID === undefined) {
            throw new Error('Required parameter moduleID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDPost.');
        }

        if (recordID === null || recordID === undefined) {
            throw new Error('Required parameter recordID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDPost.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/x-www-form-urlencoded'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/compose/namespace/${encodeURIComponent(String(namespaceID))}/module/${encodeURIComponent(String(moduleID))}/record/${encodeURIComponent(String(recordID))}`,
                    composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDPostRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * List record revisions
     * 
     * @param namespaceID Namespace ID
     * @param moduleID Module ID
     * @param recordID ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDRevisionsGet(namespaceID: string, moduleID: string, recordID: string, ): Observable<AxiosResponse<any>>;
    public composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDRevisionsGet(namespaceID: string, moduleID: string, recordID: string, ): Observable<any> {
        if (namespaceID === null || namespaceID === undefined) {
            throw new Error('Required parameter namespaceID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDRevisionsGet.');
        }

        if (moduleID === null || moduleID === undefined) {
            throw new Error('Required parameter moduleID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDRevisionsGet.');
        }

        if (recordID === null || recordID === undefined) {
            throw new Error('Required parameter recordID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDRevisionsGet.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<any>(`${this.basePath}/compose/namespace/${encodeURIComponent(String(namespaceID))}/module/${encodeURIComponent(String(moduleID))}/record/${encodeURIComponent(String(recordID))}/revisions`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Fire compose:record trigger
     * 
     * @param namespaceID Namespace ID
     * @param moduleID Module ID
     * @param recordID ID
     * @param composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDTriggerPostRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDTriggerPost(namespaceID: string, moduleID: string, recordID: string, composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDTriggerPostRequest?: ComposeNamespaceNamespaceIDModuleModuleIDRecordRecordIDTriggerPostRequest, ): Observable<AxiosResponse<any>>;
    public composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDTriggerPost(namespaceID: string, moduleID: string, recordID: string, composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDTriggerPostRequest?: ComposeNamespaceNamespaceIDModuleModuleIDRecordRecordIDTriggerPostRequest, ): Observable<any> {
        if (namespaceID === null || namespaceID === undefined) {
            throw new Error('Required parameter namespaceID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDTriggerPost.');
        }

        if (moduleID === null || moduleID === undefined) {
            throw new Error('Required parameter moduleID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDTriggerPost.');
        }

        if (recordID === null || recordID === undefined) {
            throw new Error('Required parameter recordID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDTriggerPost.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/x-www-form-urlencoded'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/compose/namespace/${encodeURIComponent(String(namespaceID))}/module/${encodeURIComponent(String(moduleID))}/record/${encodeURIComponent(String(recordID))}/trigger`,
                    composeNamespaceNamespaceIDModuleModuleIDRecordRecordIDTriggerPostRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Generates report from module records
     * 
     * @param dimensions Dimensions (eg: \&#39;DATE(foo), status\&#39;)
     * @param namespaceID Namespace ID
     * @param moduleID Module ID
     * @param metrics Metrics (eg: \&#39;SUM(money), MAX(calls)\&#39;)
     * @param filter Filter (eg: \&#39;DATE(foo) &gt; 2010\&#39;)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public composeNamespaceNamespaceIDModuleModuleIDRecordReportGet(dimensions: string, namespaceID: string, moduleID: string, metrics?: string, filter?: string, ): Observable<AxiosResponse<any>>;
    public composeNamespaceNamespaceIDModuleModuleIDRecordReportGet(dimensions: string, namespaceID: string, moduleID: string, metrics?: string, filter?: string, ): Observable<any> {
        if (dimensions === null || dimensions === undefined) {
            throw new Error('Required parameter dimensions was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordReportGet.');
        }

        if (namespaceID === null || namespaceID === undefined) {
            throw new Error('Required parameter namespaceID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordReportGet.');
        }

        if (moduleID === null || moduleID === undefined) {
            throw new Error('Required parameter moduleID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordReportGet.');
        }

        let queryParameters = new URLSearchParams();
        if (metrics !== undefined && metrics !== null) {
            queryParameters.append('metrics', <any>metrics);
        }
        if (dimensions !== undefined && dimensions !== null) {
            queryParameters.append('dimensions', <any>dimensions);
        }
        if (filter !== undefined && filter !== null) {
            queryParameters.append('filter', <any>filter);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<any>(`${this.basePath}/compose/namespace/${encodeURIComponent(String(namespaceID))}/module/${encodeURIComponent(String(moduleID))}/record/report`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Fire compose:record trigger
     * 
     * @param namespaceID Namespace ID
     * @param moduleID Module ID
     * @param composeNamespaceNamespaceIDTriggerPostRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public composeNamespaceNamespaceIDModuleModuleIDRecordTriggerPost(namespaceID: string, moduleID: string, composeNamespaceNamespaceIDTriggerPostRequest?: ComposeNamespaceNamespaceIDTriggerPostRequest, ): Observable<AxiosResponse<any>>;
    public composeNamespaceNamespaceIDModuleModuleIDRecordTriggerPost(namespaceID: string, moduleID: string, composeNamespaceNamespaceIDTriggerPostRequest?: ComposeNamespaceNamespaceIDTriggerPostRequest, ): Observable<any> {
        if (namespaceID === null || namespaceID === undefined) {
            throw new Error('Required parameter namespaceID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordTriggerPost.');
        }

        if (moduleID === null || moduleID === undefined) {
            throw new Error('Required parameter moduleID was null or undefined when calling composeNamespaceNamespaceIDModuleModuleIDRecordTriggerPost.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/x-www-form-urlencoded'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/compose/namespace/${encodeURIComponent(String(namespaceID))}/module/${encodeURIComponent(String(moduleID))}/record/trigger`,
                    composeNamespaceNamespaceIDTriggerPostRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
}
