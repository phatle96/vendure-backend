/**
 * Corteza system API
 * Corteza system REST API definition
 *
 * The version of the OpenAPI document: 2022.9
 * Contact: info@cortezaproject.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { AxiosResponse } from 'axios';
import { Observable, from, of, switchMap } from 'rxjs';
import { SystemRolesRoleIDTriggerPostRequest } from '../model/systemRolesRoleIDTriggerPostRequest';
import { SystemUsersImportPostRequest } from '../model/systemUsersImportPostRequest';
import { SystemUsersPostRequest } from '../model/systemUsersPostRequest';
import { SystemUsersUserIDPasswordPostRequest } from '../model/systemUsersUserIDPasswordPostRequest';
import { SystemUsersUserIDPutRequest } from '../model/systemUsersUserIDPutRequest';
import { Configuration } from '../configuration';
import { COLLECTION_FORMATS } from '../variables';


@Injectable()
export class UsersService {

    protected basePath = 'http://localhost';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();
    protected httpClient: HttpService;

    constructor(httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
        this.httpClient = configuration?.httpClient || httpClient;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * Export users
     * 
     * @param filename Output filename
     * @param inclRoleMembership Include role membership
     * @param inclRoles Include roles
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public systemUsersExportFilenameZipGet(filename: string, inclRoleMembership?: boolean, inclRoles?: boolean, ): Observable<AxiosResponse<any>>;
    public systemUsersExportFilenameZipGet(filename: string, inclRoleMembership?: boolean, inclRoles?: boolean, ): Observable<any> {
        if (filename === null || filename === undefined) {
            throw new Error('Required parameter filename was null or undefined when calling systemUsersExportFilenameZipGet.');
        }

        let queryParameters = new URLSearchParams();
        if (inclRoleMembership !== undefined && inclRoleMembership !== null) {
            queryParameters.append('inclRoleMembership', <any>inclRoleMembership);
        }
        if (inclRoles !== undefined && inclRoles !== null) {
            queryParameters.append('inclRoles', <any>inclRoles);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<any>(`${this.basePath}/system/users/export/${encodeURIComponent(String(filename))}.zip`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Search users (Directory)
     * 
     * @param userID Filter by user ID
     * @param roleID Filter by role membership
     * @param query Search query to match against users
     * @param username Search username to match against users
     * @param email Search email to match against users
     * @param handle Search handle to match against users
     * @param kind Kind (normal, bot)
     * @param incDeleted [Deprecated] Include deleted users (requires \&#39;access\&#39; permission)
     * @param incSuspended [Deprecated] Include suspended users
     * @param deleted Exclude (0, default), include (1) or return only (2) deleted users
     * @param suspended Exclude (0, default), include (1) or return only (2) suspended users
     * @param labels Labels
     * @param limit Limit
     * @param incTotal Include total counter
     * @param pageCursor Page cursor
     * @param sort Sort items
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public systemUsersGet(userID?: Array<string>, roleID?: Array<string>, query?: string, username?: string, email?: string, handle?: string, kind?: string, incDeleted?: boolean, incSuspended?: boolean, deleted?: string, suspended?: string, labels?: string, limit?: string, incTotal?: boolean, pageCursor?: string, sort?: string, ): Observable<AxiosResponse<any>>;
    public systemUsersGet(userID?: Array<string>, roleID?: Array<string>, query?: string, username?: string, email?: string, handle?: string, kind?: string, incDeleted?: boolean, incSuspended?: boolean, deleted?: string, suspended?: string, labels?: string, limit?: string, incTotal?: boolean, pageCursor?: string, sort?: string, ): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (userID) {
            userID.forEach((element) => {
                queryParameters.append('userID', <any>element);
            })
        }
        if (roleID) {
            roleID.forEach((element) => {
                queryParameters.append('roleID', <any>element);
            })
        }
        if (query !== undefined && query !== null) {
            queryParameters.append('query', <any>query);
        }
        if (username !== undefined && username !== null) {
            queryParameters.append('username', <any>username);
        }
        if (email !== undefined && email !== null) {
            queryParameters.append('email', <any>email);
        }
        if (handle !== undefined && handle !== null) {
            queryParameters.append('handle', <any>handle);
        }
        if (kind !== undefined && kind !== null) {
            queryParameters.append('kind', <any>kind);
        }
        if (incDeleted !== undefined && incDeleted !== null) {
            queryParameters.append('incDeleted', <any>incDeleted);
        }
        if (incSuspended !== undefined && incSuspended !== null) {
            queryParameters.append('incSuspended', <any>incSuspended);
        }
        if (deleted !== undefined && deleted !== null) {
            queryParameters.append('deleted', <any>deleted);
        }
        if (suspended !== undefined && suspended !== null) {
            queryParameters.append('suspended', <any>suspended);
        }
        if (labels !== undefined && labels !== null) {
            queryParameters.append('labels', <any>labels);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (incTotal !== undefined && incTotal !== null) {
            queryParameters.append('incTotal', <any>incTotal);
        }
        if (pageCursor !== undefined && pageCursor !== null) {
            queryParameters.append('pageCursor', <any>pageCursor);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters.append('sort', <any>sort);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<any>(`${this.basePath}/system/users/`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Import users
     * 
     * @param systemUsersImportPostRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public systemUsersImportPost(systemUsersImportPostRequest?: SystemUsersImportPostRequest, ): Observable<AxiosResponse<any>>;
    public systemUsersImportPost(systemUsersImportPostRequest?: SystemUsersImportPostRequest, ): Observable<any> {
        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/x-www-form-urlencoded'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/system/users/import`,
                    systemUsersImportPostRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Create user
     * 
     * @param systemUsersPostRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public systemUsersPost(systemUsersPostRequest?: SystemUsersPostRequest, ): Observable<AxiosResponse<any>>;
    public systemUsersPost(systemUsersPostRequest?: SystemUsersPostRequest, ): Observable<any> {
        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/x-www-form-urlencoded'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/system/users/`,
                    systemUsersPostRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * List user\&#39;s credentials
     * 
     * @param userID ID
     * @param credentialsID Credentials ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public systemUsersUserIDCredentialsCredentialsIDDelete(userID: string, credentialsID: string, ): Observable<AxiosResponse<any>>;
    public systemUsersUserIDCredentialsCredentialsIDDelete(userID: string, credentialsID: string, ): Observable<any> {
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling systemUsersUserIDCredentialsCredentialsIDDelete.');
        }

        if (credentialsID === null || credentialsID === undefined) {
            throw new Error('Required parameter credentialsID was null or undefined when calling systemUsersUserIDCredentialsCredentialsIDDelete.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<any>(`${this.basePath}/system/users/${encodeURIComponent(String(userID))}/credentials/${encodeURIComponent(String(credentialsID))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * List user\&#39;s credentials
     * 
     * @param userID ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public systemUsersUserIDCredentialsGet(userID: string, ): Observable<AxiosResponse<any>>;
    public systemUsersUserIDCredentialsGet(userID: string, ): Observable<any> {
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling systemUsersUserIDCredentialsGet.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<any>(`${this.basePath}/system/users/${encodeURIComponent(String(userID))}/credentials`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Remove user
     * 
     * @param userID User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public systemUsersUserIDDelete(userID: string, ): Observable<AxiosResponse<any>>;
    public systemUsersUserIDDelete(userID: string, ): Observable<any> {
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling systemUsersUserIDDelete.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<any>(`${this.basePath}/system/users/${encodeURIComponent(String(userID))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Read user details
     * 
     * @param userID User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public systemUsersUserIDGet(userID: string, ): Observable<AxiosResponse<any>>;
    public systemUsersUserIDGet(userID: string, ): Observable<any> {
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling systemUsersUserIDGet.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<any>(`${this.basePath}/system/users/${encodeURIComponent(String(userID))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Add member to a role
     * 
     * @param userID User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public systemUsersUserIDMembershipGet(userID: string, ): Observable<AxiosResponse<any>>;
    public systemUsersUserIDMembershipGet(userID: string, ): Observable<any> {
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling systemUsersUserIDMembershipGet.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<any>(`${this.basePath}/system/users/${encodeURIComponent(String(userID))}/membership`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Remove role from a user
     * 
     * @param roleID Role ID
     * @param userID User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public systemUsersUserIDMembershipRoleIDDelete(roleID: string, userID: string, ): Observable<AxiosResponse<any>>;
    public systemUsersUserIDMembershipRoleIDDelete(roleID: string, userID: string, ): Observable<any> {
        if (roleID === null || roleID === undefined) {
            throw new Error('Required parameter roleID was null or undefined when calling systemUsersUserIDMembershipRoleIDDelete.');
        }

        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling systemUsersUserIDMembershipRoleIDDelete.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<any>(`${this.basePath}/system/users/${encodeURIComponent(String(userID))}/membership/${encodeURIComponent(String(roleID))}`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Add role to a user
     * 
     * @param roleID Role ID
     * @param userID User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public systemUsersUserIDMembershipRoleIDPost(roleID: string, userID: string, ): Observable<AxiosResponse<any>>;
    public systemUsersUserIDMembershipRoleIDPost(roleID: string, userID: string, ): Observable<any> {
        if (roleID === null || roleID === undefined) {
            throw new Error('Required parameter roleID was null or undefined when calling systemUsersUserIDMembershipRoleIDPost.');
        }

        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling systemUsersUserIDMembershipRoleIDPost.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/system/users/${encodeURIComponent(String(userID))}/membership/${encodeURIComponent(String(roleID))}`,
                    null,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Set\&#39;s or changes user\&#39;s password
     * 
     * @param userID User ID
     * @param systemUsersUserIDPasswordPostRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public systemUsersUserIDPasswordPost(userID: string, systemUsersUserIDPasswordPostRequest?: SystemUsersUserIDPasswordPostRequest, ): Observable<AxiosResponse<any>>;
    public systemUsersUserIDPasswordPost(userID: string, systemUsersUserIDPasswordPostRequest?: SystemUsersUserIDPasswordPostRequest, ): Observable<any> {
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling systemUsersUserIDPasswordPost.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/x-www-form-urlencoded'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/system/users/${encodeURIComponent(String(userID))}/password`,
                    systemUsersUserIDPasswordPostRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Patch user (experimental)
     * 
     * @param userID User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public systemUsersUserIDPatch(userID: string, ): Observable<AxiosResponse<any>>;
    public systemUsersUserIDPatch(userID: string, ): Observable<any> {
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling systemUsersUserIDPatch.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.patch<any>(`${this.basePath}/system/users/${encodeURIComponent(String(userID))}`,
                    null,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Update user details
     * 
     * @param userID User ID
     * @param systemUsersUserIDPutRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public systemUsersUserIDPut(userID: string, systemUsersUserIDPutRequest?: SystemUsersUserIDPutRequest, ): Observable<AxiosResponse<any>>;
    public systemUsersUserIDPut(userID: string, systemUsersUserIDPutRequest?: SystemUsersUserIDPutRequest, ): Observable<any> {
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling systemUsersUserIDPut.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/x-www-form-urlencoded'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<any>(`${this.basePath}/system/users/${encodeURIComponent(String(userID))}`,
                    systemUsersUserIDPutRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Remove all auth sessions of user
     * 
     * @param userID ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public systemUsersUserIDSessionsDelete(userID: string, ): Observable<AxiosResponse<any>>;
    public systemUsersUserIDSessionsDelete(userID: string, ): Observable<any> {
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling systemUsersUserIDSessionsDelete.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<any>(`${this.basePath}/system/users/${encodeURIComponent(String(userID))}/sessions`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Suspend user
     * 
     * @param userID User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public systemUsersUserIDSuspendPost(userID: string, ): Observable<AxiosResponse<any>>;
    public systemUsersUserIDSuspendPost(userID: string, ): Observable<any> {
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling systemUsersUserIDSuspendPost.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/system/users/${encodeURIComponent(String(userID))}/suspend`,
                    null,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Fire system:user trigger
     * 
     * @param userID ID
     * @param systemRolesRoleIDTriggerPostRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public systemUsersUserIDTriggerPost(userID: string, systemRolesRoleIDTriggerPostRequest?: SystemRolesRoleIDTriggerPostRequest, ): Observable<AxiosResponse<any>>;
    public systemUsersUserIDTriggerPost(userID: string, systemRolesRoleIDTriggerPostRequest?: SystemRolesRoleIDTriggerPostRequest, ): Observable<any> {
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling systemUsersUserIDTriggerPost.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'application/x-www-form-urlencoded'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/system/users/${encodeURIComponent(String(userID))}/trigger`,
                    systemRolesRoleIDTriggerPostRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Undelete user
     * 
     * @param userID User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public systemUsersUserIDUndeletePost(userID: string, ): Observable<AxiosResponse<any>>;
    public systemUsersUserIDUndeletePost(userID: string, ): Observable<any> {
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling systemUsersUserIDUndeletePost.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/system/users/${encodeURIComponent(String(userID))}/undelete`,
                    null,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
    /**
     * Unsuspend user
     * 
     * @param userID User ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public systemUsersUserIDUnsuspendPost(userID: string, ): Observable<AxiosResponse<any>>;
    public systemUsersUserIDUnsuspendPost(userID: string, ): Observable<any> {
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling systemUsersUserIDUnsuspendPost.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/system/users/${encodeURIComponent(String(userID))}/unsuspend`,
                    null,
                    {
                        withCredentials: this.configuration.withCredentials,
                        headers: headers
                    }
                );
            })
        );
    }
}
